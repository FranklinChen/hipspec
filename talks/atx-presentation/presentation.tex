%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\documentclass[serif,professionalfont]{beamer}
\def\maindocument{} % To tell tikz images that they are not stand alone

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,calc}
\usepackage{verbatim}

% \usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
%\usepackage{fixltx2e}
%\usepackage{graphicx}
%\usepackage{longtable}
%\usepackage{float}
%\usepackage{wrapfig}
%\usepackage{soul}
%
%\usepackage{textcomp}
%\usepackage{marvosym}
%\usepackage{wasysym}
%\usepackage{latexsym}
\usepackage{amssymb}

\usepackage{hyperref}

\usepackage{mathpartir}
\usepackage{color}
%\tolerance=1000
\usepackage{inconsolata}
\usepackage{amsmath}
\usepackage{array}
\providecommand{\alert}[1]{\textbf{#1}}

\definecolor{Purpleee}{RGB}{140,20,140}
\definecolor{PurpleL}{RGB}{255,170,255}
\definecolor{MyGreen}{RGB}{5,95,5}
\setbeamercolor{title}{fg=Purpleee}
\setbeamercolor{frametitle}{fg=Purpleee}
\setbeamercolor{structure}{fg=Purpleee}


\TeXXeTstate=1
\usepackage{mathspec,xltxtra,xunicode}
% \setsansfont{Gill Sans}

% \setmainfont[Scale=1]{Gill Sans}
%\setmonofont[Scale=0.8]{Monaco}
\setmonofont{Inconsolata}

% \setmathsfont(Digits,Latin,Greek){Gill Sans}

\usefonttheme[onlymath]{serif}

%\usepackage{fontspec}
%\defaultfontfeatures{Mapping=tex-text}
%\setsansfont[Ligatures={Common}]{Futura}


\usepackage{listings}

\lstnewenvironment{codex}[1][]%
  {\noindent
   \minipage{\linewidth}
   \vspace{0.2\baselineskip}
%   \vspace{-0.4\baselineskip}
   \lstset{basicstyle=\ttfamily,
%           frame=single,
           language=Haskell,
           keywordstyle=\color{black},
           #1}}
  {%\vspace{-0.8\baselineskip}
   \endminipage}

\title{{\Huge HipSpec}}
\subtitle{{\LARGE Automating Inductive Proofs \\ using Theory Exploration}}
\institute{Chalmers University of Technology}

\author{Dan Ros\'en
     \vspace{\baselineskip} \\
     Koen Claessen, Moa Johansson, Nicholas Smallbone}
\date{May 31, 2013}

\newcommand\fa[1]{ \forall \, #1 . \,}
\newcommand\faa[2]{ \forall \, #1 , #2 . \,}
\newcommand\faaa[3]{ \forall \, #1 , #2 , #3 . \,}
\newcommand\faaaa[4]{ \forall \, #1 , #2 , #3 , #4 . \,}
\newcommand\up[0]{\vspace{-\baselineskip}}
\newcommand\dn[0]{\vspace{\baselineskip}}
\newcommand\hs[1]{\texttt{#1}}

\newcommand\x[0]{\hs{x}}
\newcommand\xs[0]{\hs{xs}}
\newcommand\ys[0]{\hs{ys}}
\newcommand\xxs[0]{\hs{x:xs}}
\newcommand\nil[0]{\hs{[]}}
\newcommand\p[1]{\textsf{P}(#1)}

\newcommand{\highlight}[1]{\colorbox{PurpleL}{\ensuremath{#1}}}

\begin{document}

\maketitle

\defverbatim{\rotatedef}{%
\begin{verbatim}
    rotate :: Nat -> [a] -> [a]
    rotate Z     xs     = xs
    rotate (S n) []     = []
    rotate (S n) (x:xs) = rotate n (xs ++ [x])
\end{verbatim}
}

\defverbatim{\rotateex}{%
\begin{verbatim}
    rotate 1 [1,2,3,4] = [2,3,4,1]
    rotate 2 [1,2,3,4] = [3,4,1,2]
    rotate 3 [1,2,3,4] = [4,1,2,3]
    rotate 4 [1,2,3,4] = [1,2,3,4]
\end{verbatim}
}

\defverbatim{\rotateprop}{%
\begin{equation*}
    \fa{\xs} \hs{rotate (length xs) xs} = \hs{xs}
\end{equation*}
}

\defverbatim{\rotategen}{%
\begin{equation*}
    \faa{\xs}{\ys} \hs{rotate (length xs) (xs ++ ys)} = \hs{ys ++ xs}
\end{equation*}
}

\defverbatim{\rotatestep}{%
\begin{align*}
    \hs{rotate (length (x:xs)) (x:xs) } & = \\
    \hs{rotate (S (length xs)) (x:xs) } & = \\
    \hs{rotate (length xs) (xs ++ [x])} & =
\end{align*}
}

\defverbatim[colored]{\stuck}{%
\begin{center}
  {\color{red} Stuck!}
\end{center}
}

\defverbatim{\sortedprop}{%
\begin{equation*}
  \fa{\xs}  \hs{sorted (isort xs)} = \hs{True}
\end{equation*}
}

\begin{frame}[fragile]
    \frametitle{Rotate example}

    \begin{overprint}
    \rotatedef

    \onslide<1> \rotateex

    \onslide<2> \rotateex \rotateprop

    \onslide<3> \rotateprop

    \onslide<4> \rotateprop \rotatestep

    \onslide<5> \rotateprop \rotatestep \stuck

    \end{overprint}

\end{frame}

% Rotate demo

% We're doing theory exploration right now, to conjecture useful lemmas,
% done by a tool called QuickSpec,
% Now we've started proving things by induction, and these properties
% were not specified in the source code but were conjectured during TE
% oh there's our property being proved! hooray!

\begin{frame}
    \frametitle{HipSpec vs Rotate}

    \rotategen

    \pause
    \begin{center}
    (also requires associativity and right identity of \hs{++})
    \end{center}

\end{frame}

\begin{comment} % old setting
  Prove properties of functional programs using rewriting and
  induction.

  {\color{Purpleee} Problem:} Som properties require lemmas to be proved, that

  \begin{itemize}
    \item Needs to be conjectured,
    \item Requires induction to be proved, and
    \item Might require lemmas themselves
  \end{itemize}
\end{comment}


\begin{frame}
    \frametitle{QuickSpec: the Theory Exploration Phase}
    Generates well-typed terms up to some depth:
    \dn
    \input{terms}
\end{frame}

\begin{frame}
    \frametitle{Partitioning into Equivalence Classes}

    \input{eqclasses}
    % read off the equations from the classes

    % completeness up to some depth

    % false properties are not a problem given that
    % the function definitions do not have tricky corner cases
    % that the random value generators do not cover
\end{frame}

\begin{frame}[fragile]
  \frametitle{Hip: The Haskell Inductive Prover}

  \begin{itemize}
    \item Translate to typed first order logic
    \item Apply structural induction
          % in many different ways

  \end{itemize}

  Also supports higher-order functions and partial application
\end{frame}

\begin{frame}
  \frametitle{Overview of HipSpec}
  \input{hipspec-picture}
  \pause
  \begin{itemize}
    \item Try to prove ``smallest'' unproved equation
    \item Terminate everything is proved (or when the current theory cannot prove any more open conjectures)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Prioritising Equations}
  \begin{itemize}
      \item Call graph
      \item Number of variables
      \item Size of term
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Evaluation Results}

1st test suite from \emph{Case-analysis for Rippling and Inductive Proof}:

\begin{center}
\begin{tabular}{c>{\hskip0.5em}c>{\hskip0.5em}c>{\hskip0.5em}c>{\hskip0.5em}c>{\hskip0.5em}c}
   \#Props  & HipSpec & Zeno & ACL2s & IsaPlanner & Dafny \\
\hline
    85      & 80      & 82   & 74    & 47         & 45    \\
\end{tabular}
\end{center}

\pause

2nd test suite from \emph{Productive use of Failure in Inductive Proof}:

\begin{center}
\begin{tabular}{c>{\hskip0.5em}c>{\hskip0.5em}c>{\hskip0.5em}c}
    \#Props  & HipSpec & CLAM & Zeno \\
\hline
    50       & 44      & 41   & 21
\end{tabular}
\end{center}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Conjecturing Conditionals}

  \sortedprop

  \begin{verbatim}
    isort :: [Nat] -> [Nat]

    insert :: Nat -> [Nat] -> [Nat]

    sorted :: [Nat] -> Bool
  \end{verbatim}

  \pause

  % It's one property that we currently cannot prove fully automatically

  Requires:

  \begin{equation*}
    \fa{\xs}  \hs{sorted xs} = \hs{True} \Rightarrow
              \hs{sorted (insert x xs)} = \hs{True}
  \end{equation*}

  % How do we conjecture such properties?
  % Currently, QuickSpec is implemented at looking at equivalence classes that
  % are unconditionally true... would like to have some kind of precondition on
  % certain equivalence classes to talk about when xs is always sorted, for
  % instance. Another problem might be that it is so uncommon to generate
  % sorted lists, so we will probably need to incorporate other ongoing work on
  % generating random values satisfying some predicate.

\end{frame}

\begin{frame}[fragile]
  \frametitle{Example tricky equational proof}

  \begin{equation*}
      \faa{\hs{i}}{\xs} \hs{rev (drop i xs)} = \hs{take (length xs - i) (rev xs)}
  \end{equation*}

  \pause

  \dn

  Required lemmas:

  \begin{center}
  \begin{verbatim}
  length (drop x xs)          = length xs - x
  length (rev xs)             = length xs
  take x xs ++ drop x xs      = xs
  rev xs ++ rev ys            = rev (ys++xs)
  take (length xs) (xs ++ ys) = xs
  \end{verbatim}
  \end{center}

  \begin{comment}
  \pause

  \begin{align*}
  & \hspace{-2em} \small \hs{rev (drop i xs)}                                                   & \small = \left\{ 5 \right\} \\[-3pt]
  & \hspace{-2em} \small \hs{take (len (rev (drop i xs))) (rev (drop i xs)++rev (take i xs))}   & \small = \left\{ 2 \right\} \\[-3pt]
  & \hspace{-2em} \small \hs{take (len (drop i xs)) (rev (drop i xs)++rev (take i xs))}         & \small = \left\{ 1 \right\} \\[-3pt]
  & \hspace{-2em} \small \hs{take (len xs-i) (rev (drop i xs)++rev (take i xs))}                & \small = \left\{ 4 \right\} \\[-3pt]
  & \hspace{-2em} \small \hs{take (len xs-i) (rev (take i xs++drop i xs))}                      & \small = \left\{ 3 \right\} \\[-3pt]
  & \hspace{-2em} \small \hs{take (len xs-i) (rev xs)}
  \end{align*}
  \end{comment}
\end{frame}

% here we can contrast with other kinds of theory exploration
% system

\begin{frame}
  \frametitle{Rotate, revisited}

    \rotateprop \rotatestep \stuck

    \pause

    \begin{itemize}
        \item Top-down: Rippling/critics-based provers, ACL, Zeno
            \pause
        \item Bottom-up: IsaCosy, IsaScheme, HipSpec
    \end{itemize}

\end{frame}

% "So the tools IsaCosy and IsaScheme can conjecture a theory,
% but not fully automatically when proving a user-stated property,
% which is what HipSpec can. But HipSpec can also be run without
% specifying what to prove! Let's have a look at the output
% of when rotate was run"

% See, the property we wanted to prove was conjectured by quickspec.
% And of course it is! It is within the depth limit, so this is fully
% expected. So we could run this example without specifying that this
% is the property we want to show, and it will still prove it!
% But instead of looking at that, let's look at another common
% problem in this literature, namely rev/qrev...
% (explanation + BAM)
% Another example is this, so we have unary/peano nats and plus
% and multiplication defined over this. So we should expect
% that hipspec can prove that this is a commutative semiring...
% let's try...

\begin{frame}
  \frametitle{HipSpec the Theory Exploration System}

  % so this is what we just seen

  \begin{center}
      Saturate a theory and have it nicely presented
  \end{center}

  \dn
  \pause

  % other examples that we can do:

  \begin{itemize}
      \item \hs{data Integer = Positive Nat | Negative Nat}
      \item \hs{data BinNat  = Zero | ZeroAnd BinNat | OneAnd BinNat}
  \end{itemize}

  % so this is an interesting piece of work to hook this up
  % with an interactive theorem prover, isa/coq/agda
  % ... could make us spend less time on proving boring properties ;)

\end{frame}

\begin{frame}[fragile]
  \frametitle{Theory Exploration Results}
  \newcommand{\h}[2]{\action<#1->{#2}}
  \begin{center}
  \begin{tabular}{lc>{\hskip0.5em}c>{\hskip0.5em}c>{\hskip0.5em}c}
                           & Isabelle & \h{2}{HipSpec}    & \h{3}{IsaCoSy} & \h{3}{IsaScheme}  \\
      \cline{2-5}
   \textbf{\#Thms Nats}    & 12       & \h{2}{10     }    & \h{3}{16     } & \h{3}{16*      }  \\
  \hline
    Precision              & -        & \h{2}{80\%   }    & \h{3}{63\%   } & \h{3}{100\%*   }  \\
    Recall                 & -        & \h{2}{73\%   }    & \h{3}{83\%   } & \h{3}{46\%*    }  \\
  \hline
   \textbf{\#Thms Lists}   & 9        & \h{4}{10     }    & \h{4}{24     } & \h{4}{13       }  \\
  \hline
    Precision              & -        & \h{4}{90\%   }    & \h{4}{38\%   } & \h{4}{70\%     }  \\
    Recall                 & -        & \h{4}{100\%  }    & \h{4}{100\%  } & \h{4}{100\%    }  \\
   \hline
   \h{5}{\textbf{Runtime}} &          & \h{5}{30 seconds} & \h{5}{hours}   & \h{5}{hours}
  \end{tabular}
  \end{center}

\end{frame}

% how to jump to conclusions/rounding off here in a reasonable way?

\begin{frame}
  \frametitle{Conclusions}
  \begin{itemize}
    \item Evaluate your programs!
    \item Completeness up to a certain depth: \\
          \emph{If the lemma is there, HipSpec will eventually try to prove it!}
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{}
\begin{center}
\hs{github.com/danr/hipspec}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conditionals as functions}

  \sortedprop

\begin{verbatim}
  whenSorted :: [Nat] -> [Nat]
  whenSorted xs = if sorted xs then xs else []
\end{verbatim}

  \begin{equation*}
    \faa{\hs{x}}{\xs} \hs{sorted (insert x (whenSorted xs))} = \hs{True}
  \end{equation*}

\begin{verbatim}
  sorted (insert x (whenSorted xs))
= sorted (insert x (if sorted xs then xs else []))
= if sorted xs then sorted (insert x xs)
               else sorted (insert x [])
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What is HipSpec?}
\tikzstyle{block} = [rectangle, draw=Purpleee, thick, text width=4.75em, text centered]


\makebox[\textwidth][c]{\
\begin{tikzpicture}

  \node at (0,0) [block,text width=120] (src) {\
\\
\textbf{Haskell source}
{\small
\begin{align*}
&\hs{rev [] = []} \\
&\hs{rev (x:xs)} \\
&\quad\hs{= rev xs ++ [x]} \\ \\
&\hs{prop\_rev xs} \\
&\quad\hs{= rev (rev xs) =:= xs}
\end{align*}
}
};
%\pause
  \node at (5,2) [block,text width=120] (hip) {\
\textbf{Hip}
\\
\emph{Haskell Inductive Prover}
\begin{itemize}
\item FOL translation
\item Apply induction
\item Success% \pause
, or stuck!
\end{itemize}
};
%\invisible<1-3>{
  \node at (5,-2)  [block,text width=120] (qs) {\
\textbf{QuickSpec}
\\
Eq-theory from testing:
\vspace{-0.5\baselineskip}
{\small
\begin{align*}
&\hs{rev (xs ++ ys)} \\
&\quad\hs{= rev ys ++ rev xs} \\
&\hs{xs ++ [] = []} \\
&\hs{xs ++ (ys ++ zs) =} \\
&\quad\hs{(xs ++ ys) ++ zs}
\end{align*}
}
};

 % \onslide<5>{
    \node at (8.5,-2) [block] (lemmas)
       {\textbf{HipSpec} \\ \emph{Use these as lemmas!!}};
 % }

\end{tikzpicture}
%}
}

\end{frame}

\end{document}

